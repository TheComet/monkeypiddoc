\section{Software}

Im folgenden Abschnitt wird der Aufbau der Software beschrieben. Die Software basiert auf dem Model-View-Controller Entwurfsmuster, welches für GUI-Applikationen aufgrund seiner hohen Flexibilität und Wiederverwendbarkeit als Standard gilt. Das Model-View-Controller Prinzip basiert auf den drei Hauptklassen $Model$, $View$ und $Controller$, welche kurz erläutert werden:

\textbf{Model:} Das $Model$ enthält die Daten und Berechnungsmethoden, welche für die Software benötigt werden. Diese Daten sind unabhängig von der grafischen Darstellung der Software. Falls Daten im $Model$ geändert werden, informiert das $Model$ die Klasse $View$, welche die Daten für den Benutzer darstellt. \\
\textbf{View:} Die $View$ beinhaltet und visualisiert die Benutzeroberfläche. Sie erhält dazu die Daten der Klasse $Model$, welche grafisch dargestellt werden und leitet Eingaben an die Klasse $Controller$ weiter. In der Klasse $View$ werden keine Berechnungen durchgeführt. Das Model ist mit der $View$ mittels Observable-Observer Entwurfsmuster verknüpft, wobei das $Model$ als Observable und die $View$ als Observer agiert.\\
\textbf{Controller:} Der $Controller$ überprüft die Benutzereingaben und leitet diese, falls sie korrekt sind, zur weiteren Berechnung an das $Model$ weiter.

Im folgenden werden wiederholt Ausschnitte des Klassendiagramms gezeigt, das komplette Klassendiagramm findet sich im Anhang \ref{klassendiagramm}.


%\subsection{Beschreibung eines Benutzungsfalls (Use-Case)}
%
%Unsere Reise beginnt in der Klasse \em{InputPanel} - ein Attribut der Klasse \em{View} - mit drei Eingabefelder, die den Benutzer erlauben, die Strecke anhand der drei Parameter $T_u$, $T_g$ und $K_r$ zu beschreiben.
%
%Ist die Strecke beschrieben, so kann der Benutzer mit einer Drop-Down-Menu den gewünschten Regler selektieren. Zur Auswahl stehen \em{I}, \em{PI}, und \em{PID} zur Verfügung.
%
%Jenachdem welchen Regler der Benutzer auswählt, kann er weiter das gewünschte Überschwingen in Prozent eingeben und eine Parasitäre Zeitkonstantenfaktor definieren, welches zur Berechnung von $T_p$ gebraucht wird.
%
%Ist alles in Ordnung, so klickt der Benutzer auf den Button ``Simulieren'' und die erste Simulation wird initiiert.
%
%Die \em{View} nimmt die Eingabewerte des Benutzers und saniert sie, damit ungültige Einstellungen möglichst früh erkannt werden. Ist alles saniert, so werden die Werte an der Klasse \em{Controller} mittels der Methode \em{Controller::btSimulateAction()} übergeben.
%
%Der \em{Controller} konfiguriert das \em{Model}-Objekt mit den Eingabewerten mittels der Methoden \em{Model::setRegulatorType()} - welche den Typ zu \em{I}, \em{PI} oder \em{PID} setzt - \em{Model::setPlant()} - welche einen neuen \em{Plant}-Objekt erstellt und als Attribut der Klasse \em{Model} speichert - \em{Model::setParasiticTimeConstantFactor()}, und \em{Model::setOvershoot()}. Danach ruft sie die Methode \em{Model::simulateAll()} auf, um die Simulation zu beginnen.
%
%Das \em{Model} baut sich zuerst mit Hilfe seiner \em{Plant}-Objekt - welche die vom Benutzer eingegebene Strecke beschreibt - eine Liste von \em{CalculationCycle}-Objekten. Diese Objekte sind dazu fähig, eine gesamte Berechnung von Reglerberechnung bis zur Schrittantwort durchzuführen. Welche Regler ausgerechnet werden ist abhängig vom Auswahl des Reglertyps, also \em{I}, \em{PI} oder \em{PID}.
%
%Es wird mittels \em{Model::notifySimulationBegin()} an alle Listener mitgeteilt, dass eine Simulation beginnt. Dies bewirkt unter anderem dass sich die verschiedene Panels auf die Resultate vorbereiten können, wie zum beispiel die Tabelle löschen oder den Plot löschen.
%
%Die \em{CalculationCycle}-Klasse erbt von \em{Runnable}. Es wird ein \em{ThreadPool} erstellt und alle \em{CalculationCycle}-Objekte werden parallel ausgeführt. Das Programm wartet, bis alle Berechnungen vollendet sind.
%
%Zu diesem Zeitpunkt teilt sich der Programmfluss in einer Unmenge kleiner Teilchen auf. Wir verfolgen nur einen Pfad, nämlich die Berechnung eines PID-Reglers mittels Zellweger Methode.
%
%Beim Instanziieren der Klasse \em{CalculationCycle} wird ein \em{AbstractControllerCalculator} übergeben - in diesem Fall ein Objekt, dass als Konkrete Klasse den \em{ZellwegerPID} hat. Dieses Objekt wurde schon vom \em{Model} konfiguriert, und es muss nur \em{AbstractControllerCalculator::run()} aufgerufen werden, um einen passenden Regler für die vom Benutzer definierte Strecke zu berechnen. 
%
%Die \em{run()}-Methode führt dazu, dass die Methode \em{ZellwegerPID::calculate()} ausgeführt wird. Der implementierte Algorithmus von Herrn Zellweger wird in dieser Methode gebraucht, um ein neues \em{ControllerPID}-Objekt zu erstellen.

\subsection{Model}

Das \em{Model} ist das Herzstück sämtlicher Berechnungen. Dazu führt es folgende Funktionen aus:

\begin{itemize}
	\item Die Koordination der unabhängigen und parallel verlaufenden Berechnungen der Reglertypen und deren Schrittantworten.
	\item Das Verwalten der dazu notwendigen Objekte, beispielsweise die Sani-Kurven.
	\item Die Implementation des iterativen Approximationsverfahren zur genauen Bestimmung des Überschwingens.
\end{itemize}

%Das Model ist das Herzstück aller Berechnungen. Es koordiniert die unabhängigen, parallel
%verlaufenden Berechnungen der Reglertypen wie auch deren Schrittantworten, es verwaltet
%die dazu notwendigen Objekte wie zum Beispiel die Sani-Kurven und es implementiert das
%iterative Approximationsverfahren zur genauen Bestimmung des Überschwingens.

\begin{figure}[h]
	\centering
		\includegraphics[width=0.60\textwidth]{model.png}
	\caption{Klassendiagramm des Models}
	\label{fig:model}
\end{figure}

\newpage
Als erstes wird die zu Grunde liegende Terminologie erläutert:

Unter einer \em{Calculation} versteht man den Prozess, einen Regler zu berechnen, einen geschlossenen Regelkreis zu erstellen und davon die Schrittantwort zu berechnen. Es gibt meistens mehrere \em{Calculations} für jede \em{Simulation}. Eine \em{Calculation} wird von der inneren Klasse \em{CalculationCycle} implementiert.

Eine \em{Simulation} beinhaltet mehrere \em{Calculations} (nämlich genau soviele, wie es Reglertypen hat). Unter \em{Simulation} versteht man den Prozess, alle zu den entsprechenden Parametern gehörenden \em{Calculations} durchzuführen. Da die \em{Calculations} rechenintensiv, aber von einander unabhängig sind, implementiert die Klasse \em{CalculationCycle}
das Interface \em{Runnable}, damit die Berechnungen mittels einem Thread-Pool parallel verlaufen können. Eine \em{Simulation} wird direkt von der \em{Model}-Klasse übernommen.

Der Prozess, die Schrittantwort eines geschlossenen Regelkreises zu berechnen, fängt mit der Erstellung eines \em{Plant}-Objektes an, welches die zu regelnde Strecke beschreibt. Es gibt sehr viele Möglichkeiten und Verfahren, einen passenden Regler für die Strecke
zu berechnen, was auch von der komplexen Vererbungshierarchie der verschiedenen \em{AbstractControllerCalculator}-Klassen reflektiert wird. Was zwischen den Rechner-Klassen gemeinsam bleibt, ist, dass sie als Eingabe ein \em{Plant}-Objekt entgegennehmen und als Ausgabe ein \em{Controller}-Objekt herausgeben. Es kann zum Beispiel mit Hilfe der \em{ZellwegerPID}-Klasse ein PID \em{Controller}-Objekt mittels der Zellweger Methodik erstellt werden. Mit dem \em{Controller}-Objekt kann zusammen mit dem \em{Plant}-Objekt ein geschlossener Regelkreis mit der Klasse \em{ClosedLoop} erstellt werden. Diese Klasse erlaubt das Berechnen einer Schrittantwort. Somit ist der Ablauf einer \em{Calculation} beschrieben.


Die \em{Model}-Klasse hat viele Methoden, die das Einstellen einer \em{Calculation} beziehungsweise einer \em{Simulation} steuern kann. Die wichtigsten Methoden sind folgend aufgezählt:

\begin{itemize}
	\item \em{Model::setPlant()}: Erlaubt es dem Benutzer, die Strecke mit den Parametern $T_u$, $T_g$ und $K_r$ zu definieren.
	\item \em{Model::setRegulatorType()}: Mit dieser Methode kann der Reglertyp ausgewählt werden. Dabei kann zwischen $I$, $PI$ und $PID$ ausgewählt werden. Insgesamt unterstützt "`Easy-PID"' 15 Varianten, einen Regler zu berechnen. Diese Methode filtert dabei die Varianten, so dass nur die Regler berechnet werden, die mit dem ausgewählten Reglertyp übereinstimmen.
	\item \em{Model::setOverswing}: Erlaubt es dem Benutzer, das gewünschte Überschwingen in Prozent einzugeben. Dabei wird bei der Zellweger-Methode der Parameter $K_r$ iterativ angepasst, bis das Überschwingen mit dem angegebenen Wert übereinstimmt. Die Faustformeln werden von dieser Methode nicht beeinflusst.
\end{itemize}

Die Methode \em{Model::setPlant()} erlaubt es dem Benutzer, die Strecke mit den
Parametern $T_u$, $T_g$, und $K_r$ zu definieren.

%Als nächstes kann der Reglertyp mit der Methode \em{Model::setRegulatorType()}
%ausgewählt werden. Dabei kann entweder $I$, $PI$, oder $PID$ eingestellt werden.
%Insgesammt unterstützt das Programm 15 verschiedene Methoden, einen Regler zu berechnen.
%Mit \em{Model::setRegulatorType()} wird bei der Simulation die Liste von
%Berechnungsarten nach dem spezifizierten Typ gefiltert, und es entstehen als Resultat nur
%Schrittantworten, die mit dem ausgewählten Typ übereinstimmen.
%
%Das bevorzugte Überschwingen kann in Prozent mit der Methode
%\em{Model::setOverswing()} angegeben werden. Dabei wird bei den Zellweger-Methoden
%der Parameter $K_r$ iterativ angepasst, bis das Überschwingen mit dem angegebenen Wert
%übereinstimmt. Die Faustformeln werden dabei nicht beeinflusst.

Ausserdem kann die parasitäre Zeitkonstante angegeben werden. Die Zellweger-Regler berechnen $T_p$, indem sie diesen Faktor mit $T_vk$ multiplizieren. Die Faustformeln berechnen $T_p$, indem sie diesen Faktor mit $T_v$ multiplizieren. Gewöhnlich wird hier etwa 10\% benutzt.



\subsubsection{Regelstrecke}

Eine Regelstrecke, im Programm vom Englischen als \em{Plant} benannt, beschreibt die zu regelnde Strecke anhand einer \em{TransferFunction} (Übertragungsfunktion), einer Liste von \em{timeConstants} (Zeitkonstanten) und natürlich anhand der Parameter
$T_u$, $T_g$ und $K_r$. Bei der Instanzierung eines \em{Plant}-Objektes werden die drei Parameter zusammen mit einer Instanz der Klasse \em{SaniCurves} übergeben.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{plant.png}
	\caption{Klassendiagramm der Regelstrecke}
	\label{fig:plant}
\end{figure}


Die Sani-Kurven sind die Grundlage zur Berechnung der \em{TransferFunction} und die \em{TransferFunction} ist die Grundlage zur späteren Berechnung der Schrittantwort.

Die Sani-Kurven werden nicht vom Programm selbst berechnet, sondern werden zu Programmbeginn aus einer Text-Datei importiert, welche wiederum von Matlab exportiert wurde. Da die Kurven als diskrete Punkte gespeichert sind, werden sie beim Importieren in Java kubisch
interpoliert, um eine höhere Auflösung zu ermöglichen. Das Interpolieren erfolgt mittels der \em{SplineNAK}-Klasse, welche von C in Java übersetzt wurde. (http://www.pcs.cnu.edu/~bbradie/cpp/interp.C). \\
Da diese Interpolationsmethode mit der in Matlab verwendeten übereinstimmt, wird ein stabiler Benchmark für Tests ermöglicht.
%Die Interpolationsmethode ist die gleiche der in Matlab verwendet wird, was uns ein
%stabiler Benchmark fürs Testen ermöblicht.

Das \em{SaniCurves}-Objekt wird nur einmal im \em{Model} erstellt, um die Festplattenzugriffszeit zu minimieren. Das \em{Model}-Objekt hat zu jedem Zeitpunkt eine Referenz auf den aktuellen \em{Plant}.

Jedes Mal, wenn sich mindestens einer der drei Parameter $T_u$, $T_g$ oder $K_r$ im \em{Plant}-Objekt ändert, sei es durch eine Instanzierung oder durch Aufrufen der Methode \em{Plant::setParameters()}, werden mittels \em{SaniCurves} die Zeitkonstanten
der Strecke und die Übertragungsfunktion neu berechnet.

%Problem/Fragestellung:
%- Wie werden die Sani-Kurven geladen, behandelt und gekapselt?
%Lösung: Die Kurven werden aus einer .txt-Datei ins Java-Programm geladen. Die Kurven werden mittels
%einer Interpolationsmethode aus der Apache-Library interpoliert.
%Ergänzung: Auch beschreiben wie die Regelstrecke gespeichert wird (Objekt) falls das so ist.


\subsubsection{Regler}

Der Regler, im Programm vom Englischen als \em{Controller} benannt, beschreibt den Regler der Strecke anhand einer \em{TransferFunction} (Übertragungsfunktion).

Nicht alle Regler haben gemeinsame Parameter. Bei den verschiedenen Reglertypen sind die Parameter anders benannt oder gar nicht vorhanden. Beispielsweise hat der PI-Regler die Parameter $T_u$ und $T_g$, aber es fehlen die PID-Parameter $T_v$ und $T_p$. Ausserdem wird abhängig vom Reglertyp die Übertragungsfunktion anders berechnet. Es gibt aber auch Gemeinsamkeiten, wie der Name oder die Farbe des Reglers und die Tatsache, dass die Parameter in einer Tabelle eingefügt werden müssen. Für den Rest des Programms ist ausserdem nicht ersichtlich, um was für einen Reglertyp es sich handelt. Für die Schrittantwort wird lediglich die Übertragungsfunktion verwendet.

Aus diesen Gründen arbeiten wir hier mit Vererbung. Die Klassen \em{ControllerI}, \em{ControllerPI} und \em{ControllerPID} implementieren jeweils die Details der entsprechenden Reglertypen. Die Superklasse \em{AbstractController} stellt eine gemeinsame Schnittstelle zur Verfügung.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{controller.png}
	\caption{Klassendiagramm des Reglers}
	\label{fig:controller}
\end{figure}


Immer, wenn sich die Reglerparameter ändern, also dann wenn der Regler instanziert wird, wird seine Übertragungsfunktion berechnet. Diese ist mittels der Methode \em{AbstractController::getTransferFunction()} abrufbar.

Jeder Regler definiert eine Farbe und einen Namen für den Plot. Auf diese Informationen kann mittels der Methoden \em{AbstractController::getName()} und \em{AbstractController::getColor()} zugegriffen werden.

Die erbenden Klassen implementieren die Methode \em{getTableRowStrings()}, welche erlaubt, die Reglerparameter über die Superklasse in die Tabelle zu einzufügen ohne zu wissen, um was für einen Reglertypen es sich handelt.

Wurde der Regler mittels einer Zellwegermethode berechnet, kann ein Fenster für den Minimal- und den Maximalwert des Parameters $K_r$ über die Methoden \em{Abstract\-Controller::get\-Min\-Kr()} und \em{AbstractController::getMaxKr()} geholt werden. Dieses Fenster wird für das iterative Approximieren des Überschwingens verwendet. Alle anderen Berechnungsmethoden, also die Faustformeln, berechnen diese Fenster nicht.



%Problem/Fragestellung:
%- Wie werden die Reglertypen (PI und PID) softwaretechnisch entkoppelt?
%- Was gibt es für Berechnungen?
%- Wie werden die Reglerberechnungsarten (Zellweger und Faustformeln) softwaretechnisch entkoppelt?
%Lösung: Um die verschiedenen Reglertypen zu entkoppeln wird eine abstrakte Klasse erstellt. Von dieser erben wiederum je eine abstrakte Klasse für die Faustformeln und eine abstrakte Klasse für die
%Zellweger-Methode.



\subsubsection{Reglerberechung}

Die Reglerberechnung ist hierarchisch und technisch das komplizierteste Teilstück des Programms. Es gibt insgesamt 15 verschiedene Klassen, die auf 15 verschiedene Arten einen passenden Regler für eine Strecke berechnen können. Alle erben von der Klasse \em{AbstractControllerCalculator}.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{controller-calculator.png}
	\caption{Klassendiagramm zur Reglerberechnung}
	\label{fig:controller-calculator}
\end{figure}


Grundlegend kann ein neues \em{ControllerCalculator}-Objekt mit einem \em{Plant}-Objekt (die Strecke) instanziert werden, es kann
\em{AbstractControllerCalculator::run()} aufgerufen werden, und es kann mittels der Methode \em{AbstractControllerCalculator::getController()} der resultierende Regler als \em{AbstractController} geholt werden.

Wie der Regler berechnet wird und welchem Typ der Regler angehört, ist dabei durch die Vererbung abstrahiert.



\subsubsection{Regelkreis}

Mit der Klasse \em{ClosedLoop} kann mit einem \em{Plant}-Objekt und einem \em{AbstractController}-Objekt ein geschlossener Regelkreis erstellt werden. Auch der \em{ClosedLoop} hat eine Übertragungsfunktion (ein \em{TransferFunction}-Objekt), welche aus den Übertragungsfunktionen der Strecke und des Reglers berechnet wird.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{closed-loop.png}
	\caption{Klassendiagramm zum Regelkreis}
	\label{fig:closed-loop}
\end{figure}


Immer wenn sich das \em{Plant}-Objekt oder das \em{AbstractController}-Objekt ändern, sei es durch eine Instanzierung oder durch Aufrufen der Methode \em{ClosedLoop::setPlantAndController()}, wird aus den beiden Übertragungsfunktionen des \em{Plant}-Objektes und des \em{AbstractController}-Objektes die Übertragungsfunktion des geschlossenen Regelkreises berechnet.

Durch Aufrufen der Methode \em{ClosedLoop::calculateStepResponse()} wird die Sprungantwort mittels der Residuenmethode berechnet. Die resultierende Schrittantwort kann mit der Methode \em{ClosedLoop::getStepResponse()} als \em{XYSeries} für JFreeChart geholt werden. Die Residuenmethode wurde gewählt, da sie robuster und schneller ist als die Variante mit IFFT. Ein Vergleich dazu ist im Abschnitt Validierung unter \ref{residuenvsifft} aufgeführt.

Weiter wird bei der Berechnung der Sprungantwort das maximale Überschwingen gemessen. Dieser Wert kann mit der Methode \em{ClosedLoop::getOverswing()} geholt werden.



\subsubsection{Resultate}

Die Resultate der Berechnungen sind die Reglerparameter $T_n$, $T_v$ und $K_r$, die parasitäre Zeitkonstante $T_p$, das Überschwingen, der Name der verwendeten Methode und die Schrittantwort. 

Die Schrittantworten werden mit JFreeChart geplottet und die restlichen Parameter können mit der Methode \em{AbstractController::getTableRowStrings()} als String-Array geholt werden und werden im GUI in eine Tabelle eingefügt.

%Problem/Fragestellung:
%- Was wird berechnet?
%- Wie werden die berechneten Resultate gespeichert?
%- Wie werden die Resultate im User-Interface dargestellt?
%Lösung: Die berechneten Regler-Parameter werden in einer Tabelle im User-Interface dargestellt. Die
%Sprungantworten werden in einem Plot dargestellt.
