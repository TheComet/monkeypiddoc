\section{Validierung}
Im folgenden Abschnitt wird die Validierung beschrieben. Die Validierung dient zum Auffinden und Beheben von Fehlern, um so eine korrekte Funktion des Programms garantieren zu können. Zum einen wurden die Berechnungen und Simulationen von Matlab überprüft, zum anderen die Software, aufgeteilt in die Teilbereiche Benutzeroberfläche und Berechnungen.

\subsection{Matlab}

\subsubsection{Programmierung}
%Problem/Fragestellung:
%- Wie kann die korrekte Funktion der Matlab-Programme überprüft werden?
%Lösung: Die berechneten Antworten werden mit den Antworten von Herrn Niklaus verglichen.
Die Berechnung der Regler wurde zuerst mittels m-Files in Matlab implementiert. Zur Überprüfung der von Matlab gelieferten Werte wurden diese mit den Werten vom Fachcoach Peter Niklaus verglichen.

\subsubsection{Simulation}
%Problem/Fragestellung:
%- Wie kann die Matlab-Simulation überprüft werden?
%Lösung: Sie wird mit Simulink überprüft.
Mittels Simulink wurde der geschlossene Regelkreis simuliert.

\subsection{Java Software}

\subsubsection{Benutzeroberfläche}
%Problem/Fragestellung:
%- Wie können Probleme oder Konflikte bei der Benutzeroberfläche ausgeschlossen werden?
%Mehrere unabhängige User testen die Software.

%Um die einfache Handhabung der Software zu überprüfen wurde die Software im ganzen Projektteam sowie von mehreren unabhängigen Benutzern getestet. Die so gefundenen Unklarheiten oder Probleme wurden behoben.

\subsubsection{Model}
%Problem/Fragestellung:
%- Wie wird die korrekte Funktion der Software überprüft?
%Lösung: Die Software mit mit JUnit getestet, wobei die Resultate von Matlab erwartet werden.
Die Plausibilität der Schrittantworten konnte relativ einfach optisch mit den Graphen überprüft werden, da das Verhalten der einzelnen Regler bekannt ist. Zur genauen Überprüfung der einzelnen Klassen wurden sämtliche Klassen des Models mittels JUnit mit den Ergebnissen von Matlab verglichen.

\subsubsection{Performancevergleich Partialbruchzerlegung und IFFT}\label{residuenvsifft}
Es wurde festgestellt dass das Berechnen des Schrittantwortes mittels IFFT-Methode merkbar langsam ist - vorallem dann, als das iterative Approximieren des Überschwingens implementiert wurde, was dazu führte, dass die Schrittantwortberechnung mehrmals ausgeführt werden musste.

Durch Reduzieren der Anzahl Punkte kann die Berechnung beschleunigt werden, jedoch kommt dies auf Kosten von Genauigkeit, was anhand des immer zunehmende Unterschwinngens in den Figuren \ref{fig:ifft_genauigkeit} zu sehen ist. Weiter sind die Anzahl Punkte bei der IFFT-Methode auf Zahlen der Basis 2 limitiert, was eine genaue Optimierung der Anzahl Punkte unmöglich macht. Durch Ausprobieren stellten wir fest, dass ein Minimum von 4096 Punkte für ein visuell genaues Resultat gebraucht wird. Dabei konnten wir auf 2048 Punkte für das iterative Approximieren des Überschwingens zurückfallen. Die Berechnungszeit war aber immer noch merkbar langsam.

\begin{figure}[h]
\centering
\begin{subfigure}{.4\textwidth}
	\centering
	\includegraphics[width=1\linewidth]{./ifft_4096.jpg}
	\caption{Schrittantwort mit 4096 Samples}
	\label{fig:ifft_genauigkeit_4096}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
	\centering
	\includegraphics[width=1\linewidth]{./ifft_2048.jpg}
	\caption{Schrittantwort mit 2048 Samples}
	\label{fig:ifft_genauigkeit_2048}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
	\centering
	\includegraphics[width=1\linewidth]{./ifft_1024.jpg}
	\caption{Schrittantwort mit 1024 Samples}
    \label{fig:ifft_genauigkeit_1024}
\end{subfigure}
\caption{Vergleich einer Schrittantwort mit verschiedene Anzahl Punkte}
\label{fig:ifft_genauigkeit}
\end{figure}

Es wurde entschieden, eine alternative Berechnungsmethode zu implementieren: Die Schrittantwortberechnung mittels Partialbruchzerlegung.

Um die Berechnungsgeschwindigkeit beider Methoden messen und vergleichen zu können, wurden mehrere Tests durchgefürht, welche hier in Detail dargelegt werden.

Die Berechnungszeit wurde mit der Methode \textit{System::currentTimeMillis()} gemessen. Weil die Messresultate stark varieren, wurde die Messung mehrmals mittels einer For-Schleife ausgeführt, wie im Java-Code in der Figur \ref{fig:time_measurement_simulate_all} zu sehen ist.

\begin{figure}[h]
	\includegraphics[width=1\linewidth]{./code_for_timing_simulations.png}
	\caption{Zeitmessung der Methode \textit{Model::simulateAll()}}
	\label{fig:time_measurement_simulate_all}
\end{figure}

Wichtig zu bemerken ist dass das Programm für jede Messung neu gestartet wurde, damit das \textit{Java Virtual Machine} (JVM) "frish" bleibt.

Aus Gründen der Reproduzierbarkeit und/oder Vergleichsmöglichkeit wurden die Messungen auf ein System mit folgenden Eigenschaften ausgeführt.
\begin{itemize}
	\item \textbf{OS:} Linux twilight 3.18.12-gentoo
	\item \textbf{Arch:} x86\textunderscore 64
	\item \textbf{CPU:} AMD Phenom(tm) II X6 1090T Processor
	\item \textbf{Java:} Oracle JDK 1.8.0.45, Java HotSpot(TM) 64-Bit Server VM
\end{itemize}

Als erstes wurden beide Methoden mit fix 2048 Punkte verglichen. 2048 Punkte sind bei der IFFT-Methode das Minimum das gebraucht wird, um ein relativ genaues Überschwingen der Zellweger Methode approximieren zu können; deswegen die Entscheidung, 2048 Punkte zu testen. Wie in der Figur \ref{fig:ifft_vs_pbz_2048} zu sehen ist, leistet die Methode mit Partialbruchzerlegung das gleiche Resultat innert halber Zeit.

\begin{figure}[h]
	\includegraphics[width=1\linewidth]{./ifft-vs-partialbruchzerlegung-2048-single-threaded.png}
	\caption{IFFT vs Partialbruchzerlegung mit fix 2048 Samples und kein Threadpool. Partialbruchzerlegung ist etwa 2 mal schneller.}
	\label{fig:ifft_vs_pbz_2048}
\end{figure}

