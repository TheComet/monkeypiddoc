\section{Validierung}
Im folgenden Abschnitt wird die Validierung beschrieben. Die Validierung dient zum Auffinden und Beheben von Fehlern, um so eine korrekte Funktion des Programms garantieren zu können. Zum einen wurden die Berechnungen und Simulationen von Matlab überprüft, zum anderen die Software, aufgeteilt in die Teilbereiche Benutzeroberfläche und Berechnungen.

\subsection{Matlab}

\subsubsection{Programmierung}
%Problem/Fragestellung:
%- Wie kann die korrekte Funktion der Matlab-Programme überprüft werden?
%Lösung: Die berechneten Antworten werden mit den Antworten von Herrn Niklaus verglichen.
Die Berechnung der Regler wurde zuerst mittels m-Files in Matlab implementiert. Zur Überprüfung der von Matlab gelieferten Werte wurden diese mit den Werten vom Fachcoach Herr Prof. Peter Niklaus verglichen.

\subsubsection{Simulation}
%Problem/Fragestellung:
%- Wie kann die Matlab-Simulation überprüft werden?
%Lösung: Sie wird mit Simulink überprüft.
Mittels Simulink und Matlab wurde der geschlossene Regelkreis simuliert.

\subsection{Java Software}

\subsubsection{Benutzeroberfläche}
%Problem/Fragestellung:
%- Wie können Probleme oder Konflikte bei der Benutzeroberfläche ausgeschlossen werden?
%Mehrere unabhängige User testen die Software.

%Um die einfache Handhabung der Software zu überprüfen wurde die Software im ganzen Projektteam sowie von mehreren unabhängigen Benutzern getestet. Die so gefundenen Unklarheiten oder Probleme wurden behoben.

\subsubsection{Model}
%Problem/Fragestellung:
%- Wie wird die korrekte Funktion der Software überprüft?
%Lösung: Die Software mit mit JUnit getestet, wobei die Resultate von Matlab erwartet werden.
Die Plausibilität der Schrittantworten konnte relativ einfach optisch mit den Graphen überprüft werden, da das Verhalten der einzelnen Regler bekannt ist. Zur genauen Überprüfung der einzelnen Klassen wurden sämtliche Klassen des Models mittels JUnit mit den Ergebnissen von Matlab verglichen.

\subsubsection{Performancevergleich von Partialbruchzerlegung und IFFT}\label{residuenvsifft}
Es wurde festgestellt, dass das Berechnen der Schrittantwort mittels IFFT-Methode langsam ist, vor allem dann, als das iterative Approximieren des Überschwingens implementiert wurde, was dazu führte, dass die Schrittantwortberechnung mehrmals ausgeführt werden musste.

Durch Reduzieren der Anzahl Punkte kann die Berechnung beschleunigt werden, jedoch geht dies auf Kosten von Genauigkeit, was anhand des immer zunehmenden Unterschwingens in der Figur \ref{fig:ifft_genauigkeit} zu sehen ist. Weiter sind die Anzahl Punkte bei der IFFT-Methode auf Zahlen der Basis 2 limitiert, was eine genaue Optimierung der Anzahl Punkte unmöglich macht. Durch Experimentieren stellten wir fest, dass ein Minimum von 4096 Punkte für ein visuell genaues Resultat gebraucht wird. Dabei konnten wir auf 2048 Punkte für das iterative Approximieren des Überschwingens zurückgehen. Die Berechnungszeit war aber immer noch merkbar langsam.

\begin{figure}[h]
\centering
\begin{subfigure}{.4\textwidth}
	\centering
	\includegraphics[width=1\linewidth]{./ifft_4096.jpg}
	\caption{Schrittantwort mit 4096 Samples}
	\label{fig:ifft_genauigkeit_4096}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
	\centering
	\includegraphics[width=1\linewidth]{./ifft_2048.jpg}
	\caption{Schrittantwort mit 2048 Samples}
	\label{fig:ifft_genauigkeit_2048}
\end{subfigure}
\begin{subfigure}{.4\textwidth}
	\centering
	\includegraphics[width=1\linewidth]{./ifft_1024.jpg}
	\caption{Schrittantwort mit 1024 Samples}
    \label{fig:ifft_genauigkeit_1024}
\end{subfigure}
\caption{Vergleich einer IFFT Schrittantwort mit verschiedener Anzahl Punkte}
\label{fig:ifft_genauigkeit}
\end{figure}

Es wurde entschieden, eine alternative Berechnungsmethode zu implementieren: Die Schrittantwortberechnung mittels Partialbruchzerlegung.

Um die Berechnungsgeschwindigkeit beider Methoden messen und vergleichen zu können, wurden mehrere Tests durchgeführt, welche hier im Detail dargelegt werden.

Die Berechnungszeit wurde mit der Methode \textit{System::currentTimeMillis()} gemessen. Weil die Messresultate stark variieren, wurde die Messung mehrmals mittels einer For-Schleife ausgeführt, wie im Java-Code in der Figur \ref{fig:code_for_timing_simulations} zu sehen ist.

\begin{figure}[h]
	\includegraphics[scale=1]{./code_for_timing_simulations.png}
	\caption{Zeitmessung der Methode \textit{Model::simulateAll()}}
	\label{fig:code_for_timing_simulations}
\end{figure}

Wichtig zu bemerken ist, dass das Programm für jede Messung neu gestartet wurde, damit die \textit{Java Virtual Machine} (JVM) ``frisch'' bleibt.

Aus Gründen der Reproduzierbarkeit und/oder Vergleichsmöglichkeit wurden die Messungen auf einem System mit folgenden Eigenschaften ausgeführt.
\begin{itemize}
	\item \textbf{OS:} Linux twilight 3.18.12-gentoo
	\item \textbf{Arch:} x86\textunderscore 64
	\item \textbf{CPU:} AMD Phenom(tm) II X6 1090T Processor
	\item \textbf{Java:} Oracle JDK 1.8.0.45, Java HotSpot(TM) 64-Bit Server VM
\end{itemize}

Als erstes wurden beide Methoden mit fix 2048 Punkten verglichen. Das sind bei der IFFT-Methode das Minimum, das gebraucht wird, um ein relativ genaues Überschwingen der Zellweger Methode approximieren zu können; deswegen die Entscheidung, mit 2048 Punkten zu testen. Wie in der Figur \ref{fig:ifft_vs_pbz_2048} zu sehen ist, leistet die Methode mit Partialbruchzerlegung das gleiche Resultat innert halber Zeit.

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\linewidth]{./ifft-vs-partialbruchzerlegung-2048-single-threaded.png}
	\caption{IFFT vs Partialbruchzerlegung mit fix 2048 Samples und keinem Threadpool. Partialbruchzerlegung ist etwa zweimal schneller.}
	\label{fig:ifft_vs_pbz_2048}
\end{figure}

Ein Nachteil der IFFT Methode ist, dass ihre Komplexität quadratisch skaliert. Die Partialbruchzerlegungsmethode hingegen skaliert nur linear. Dies ist gut ersichtlich, wenn man Figur \ref{fig:ifft_vs_pbz_2048} und \ref{fig:ifft_vs_pbz_8192} vergleicht.

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\linewidth]{./ifft-vs-partialbruchzerlegung-8192-single-threaded.png}
	\caption{IFFT vs Partialbruchzerlegung mit 8192 Samples und keinem Threadpool. Berechnungszeit von IFFT skaliert quadratisch, Partialbruchzerlegung nur linear.}
	\label{fig:ifft_vs_pbz_8192}
\end{figure}

In Realität braucht die Partialbruchzerlegungsmethode aber viel weniger als 2048 Punkte. Je nachdem was für eine Strecke vorliegt, ändern sich die Anzahl Punkte. Mit einer Strecke von $T_u=2$ und $T_g=6$ wurden in der Figur \ref{fig:pbz-single-vs-multi} nur 145 Punkte gebraucht, was zu einer Berechnungszeit von etwa 8ms führte. Die Berechnung kann mittels Multithreading weiter beschleunigt werden. In diesem Beispiel konnte sie auf weniger als 1ms reduziert werden, wie in Figur \ref{fig:pbz-single-vs-multi} auch zu sehen ist. Man beachte, dass nur 7 Berechnungen parallel liefen. Das heisst, es ist nicht auszuschliessen, dass Multithreading noch schneller sein könnte, wenn mehr Berechnungen vorhanden wären.

\begin{figure}[h]
	\centering
	\includegraphics[width=.8\linewidth]{./partialbruchzerlegung-145-single-vs-multi.png}
	\caption{Single Threaded vs Multi Threaded: Partialbruchzerlegung mit variabler Anzahl Samples}
	\label{fig:pbz-single-vs-multi}
\end{figure}
